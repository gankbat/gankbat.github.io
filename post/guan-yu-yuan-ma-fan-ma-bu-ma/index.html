<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>关于原码, 反码, 补码 | GANKBAT</title>
<meta name="description" content="持续学习">

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://blog.gankbat.com/favicon.ico?v=1568894376996">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://blog.gankbat.com/styles/main.css">


  
    <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css" />
  

  


<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>

<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />



  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://blog.gankbat.com">
        <img src="https://blog.gankbat.com/images/avatar.png?v=1568894376996" class="site-logo">
        <h1 class="site-title">GANKBAT</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/" class="site-nav">
            首页
          </a>
        
      
        
          <a href="/archives" class="site-nav">
            归档
          </a>
        
      
        
          <a href="/tags" class="site-nav">
            标签
          </a>
        
      
        
          <a href="https://blog.gankbat.com/post/guan-yu/" class="site-nav">
            关于
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
          <a class="social-link" href="https://github.com/gankbat" target="_blank">
            <i class="fab fa-github"></i>
          </a>
        
      
        
      
        
      
        
      
        
      
    </div>
    <div class="site-description">
      持续学习
    </div>
    <div class="site-footer">
      Powered by <a href="https://github.com/gankbat" target="_blank">GANKBAT</a> | <a class="rss" href="https://blog.gankbat.com/atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">关于原码, 反码, 补码</h2>
            <div class="post-date">2019-09-19</div>
            
            <div class="post-content">
              <p>计算机要使用一定的编码方式进行存储. 原码, 反码, 补码是机器存储一个具体数字的编码方式.</p>
<!-- more -->
<h2 id="1原码">1.原码</h2>
<p>原码就是符号位加上真值的绝对值, 即用第一位表示符号, 其余位表示值. 比如如果是8位二进制:</p>
<pre><code>[+1]原 = 0000 0001
</code></pre>
<pre><code>[-1]原 = 1000 0001
</code></pre>
<p>第一位是符号位. 因为第一位是符号位, 所以8位二进制数的取值范围就是:</p>
<pre><code>[1111 1111 , 0111 1111]
</code></pre>
<p>即</p>
<pre><code>[-127 , 127]
</code></pre>
<h2 id="2反码">2.反码</h2>
<p>反码的表示方法是:</p>
<p>正数的反码是其本身</p>
<p>负数的反码是在其原码的基础上, 符号位不变，其余各个位取反.</p>
<pre><code>[+1] = [00000001]原 = [00000001]反
</code></pre>
<pre><code>[-1] = [10000001]原 = [11111110]反
</code></pre>
<p>可见如果一个反码表示的是负数, 人脑无法直观的看出来它的数值. 通常要将其转换成原码再计算.</p>
<h2 id="3补码">3.补码</h2>
<p>补码的表示方法是:</p>
<p>正数的补码就是其本身</p>
<p>负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即在反码的基础上+1)</p>
<pre><code>[+1] = [00000001]原 = [00000001]反 = [00000001]补
</code></pre>
<pre><code>[-1] = [10000001]原 = [11111110]反 = [11111111]补
</code></pre>
<p>对于负数, 补码表示方式也是人脑无法直观看出其数值的. 通常也需要转换成原码在计算其数值.</p>
<p>从上面可以看到, 对于正数: 原码, 反码, 补码都是一样的, 对于负数:原码, 反码, 补码都不一样.</p>
<h2 id="关于与运算">关于&amp;与运算</h2>
<p>&amp;运算是二进制数据的计算方式, 两个操作位都为1，结果才为1，否则结果为0. 在上面的 b[n] &amp; 0XFF 计算过程中, byte 有 8bit, OXFF 是16进制的255, 表示的是 int 类型, int 有 32bit.</p>
<p>如果b[n]为 -118, 那么其原码表示为</p>
<pre><code>00000000 00000000 00000000 10001010
</code></pre>
<p>反码为</p>
<pre><code>11111111 11111111 11111111 11110101
</code></pre>
<p>补码为</p>
<pre><code>11111111 11111111 11111111 11110110
</code></pre>
<p>0XFF 表示16进制的数据255, 原码, 反码, 补码都是一样的, 其二进制数据为</p>
<pre><code>00000000 00000000 00000000 11111111
</code></pre>
<p>0XFF 和 -118 进行&amp;运算后结果为</p>
<pre><code>00000000 00000000 00000000 11110110
</code></pre>
<p>还原为原码后为</p>
<pre><code>00000000 00000000 00000000 10001010
</code></pre>
<p>其表示的 int 值为 138, 可见将 byte 类型的 -118 与 0XFF 进行与运算后值由 -118 变成了 int 类型的 138, 其中低8位和byte的-118完全一致.</p>
<p>如果b[n]为0或者正数, 其原码, 反码, 补码都是一样的, 和 0XFF 进行与运算后的结果不变.</p>
<p>byte 的取值范围为 [-128, 127], 根据上面的转换过程我们可以发现, 只有当 byte 的值为负数的时候才有必要和0XFF 进行与运算, 为0或者为正数的时候byte的值和对应int的值完全一致.</p>
<h2 id="关于无符号右移运算">关于无符号&gt;&gt;&gt;右移运算</h2>
<p>通过上面的对 原码, 反码, 补码 和 &amp;与运算的理解已经可以解答:为什么一个字节要和0XFF进行与(&amp;)运算后再传给 toHexString 方法?这个问题. 这里再深入了解一下 int 和 byte 互转的问题.</p>
<h2 id="int-转-byte数组">int 转 byte数组</h2>
<p>int 有 32bit, byte 有 8bit, 那么一个 int 转成 byte 后有 4 个byte. 过程如下</p>
<pre><code>public static byte[] intToBytes(int a) {
	byte[] intbyte = new byte[4];

	byte b = (byte) (a &gt;&gt;&gt; 24);
	byte c = (byte) (a &gt;&gt;&gt; 16);
	byte d = (byte) (a &gt;&gt;&gt; 8);
	byte e = (byte) (a);

	intbyte[0] = b;
	intbyte[1] = c;
	intbyte[2] = d;
	intbyte[3] = e;

	return intbyte;
}
</code></pre>
<p>其中用到了无符号&gt;&gt;&gt;右移运算, 为什么不用有符号&gt;&gt;右移运算呢? 两者的区别在于前者向右移动后无论当前数据是正数还是负数都用 0 来填充.</p>
<p>这里拿值为 -10 的 byte 举个例子.</p>
<pre><code>int a = -120;
System.out.println(&quot;toBinaryString(a)=&quot;+Integer.toBinaryString(a));

int b = a &gt;&gt;&gt; 2;
int c = a &gt;&gt; 2;
System.out.println(&quot;int b=&quot;+b);
System.out.println(&quot;toBinaryString(b)=&quot;+Integer.toBinaryString(b));
System.out.println(&quot;int c=&quot;+c);
System.out.println(&quot;toBinaryString(c)=&quot;+Integer.toBinaryString(c));
</code></pre>
<p>输出如下</p>
<pre><code>toBinaryString(a)=11111111111111111111111110001000
b=1073741794
toBinaryString(b)=111111111111111111111111100010
c=-30
toBinaryString(c)=11111111111111111111111111100010
</code></pre>
<p>可见对b进行无符号<code>&gt;&gt;&gt;</code>右移运算2位后, 高2位变成了00.</p>
<p>还有一点需要注意的是:无符号右移运算符 <code>&gt;&gt;&gt;</code> 只对32位和64位的值有意义.</p>
<p>回到上面 int 转 byte 的例子. 如果传入的 int 值为 55588, 其二进制表示为</p>
<pre><code>00000000 00000000 11011001 00100100
</code></pre>
<p><code>&gt;&gt;&gt; 24</code> 无符号向右移动 24 位后为(把<code>00000000 11011001 00100100</code>挤掉了,高位用0填充)</p>
<pre><code>00000000 00000000 00000000 00000000
</code></pre>
<p>转成 byte 后为<code>00000000</code> (其实就是低8位), intbyte数组下标0的值为 <code>00000000</code></p>
<p><code>&gt;&gt;&gt; 16</code> 无符号向右移动 16 位后为(把<code>11011001 00100100</code>挤掉了,高位用0填充)</p>
<pre><code>00000000 00000000 00000000 00000000
</code></pre>
<p>转成 byte 后为 <code>00000000</code>, intbyte数组下标1的值为 <code>00000000</code></p>
<p><code>&gt;&gt;&gt; 8</code> 无符号向右移动 8 位后为(把<code>00100100</code>挤掉了,高位用0填充)</p>
<pre><code>00000000 00000000 00000000 11011001
</code></pre>
<p>转成 byte 后为 <code>11011001</code>, intbyte数组下标2的值为 <code>11011001</code></p>
<p>最后intbyte数组下标3的值为 <code>00100100</code></p>
<p>经过上面的计算, 就将一个 int 转成了长度为4的 byte 数组.</p>
<h2 id="byte数组-转-int">byte数组 转 int</h2>
<p>对于上面的 byte 数组如何转回 int 呢? 方法如下</p>
<pre><code>int a = (intbyte[0] &amp; 0xFF) &lt;&lt; 24;
int b = (intbyte[1] &amp; 0xFF) &lt;&lt; 16; 
int c = (intbyte[2] &amp; 0xFF) &lt;&lt; 8; 
int d = (intbyte[3] &amp; 0xFF);
System.out.println(&quot;a|b|c|d = &quot; + (a|b|c|d));
</code></pre>
<p>其中想当然会用到&lt;&lt;左移动, 因为前面用到了右移嘛.</p>
<p>第一个 byte 先跟 <code>0XFF</code> 进行与运算转成 int, 然后向左移动 24 位变成 a</p>
<pre><code>00000000 00000000 00000000 00000000
</code></pre>
<p>第二个 byte 先跟 <code>0XFF</code> 进行与运算转成 int, 然后向左移动 16 位变成 b</p>
<pre><code>00000000 00000000 00000000 00000000
</code></pre>
<p>第三个 byte 先跟 <code>0XFF</code> 进行与运算转成 int, 然后向左移动 8 位变成 c</p>
<pre><code>00000000 00000000 11011001 00000000
</code></pre>
<p>第四个 byte 跟 <code>0XFF</code> 进行与运算转成 int d</p>
<pre><code>00000000 00000000 00000000 00100100
</code></pre>
<p>最后还要用到<code>|</code>或运算, 或运算规律：两个位只要有一个为1，那么结果就是1，否则就为0.</p>
<p>a 和 b 的或运算结果为</p>
<pre><code>00000000 00000000 00000000 00000000
</code></pre>
<p>上面的结果再和 c 的或运算结果为</p>
<pre><code>00000000 00000000 11011001 00000000
</code></pre>
<p>上面的结果再和 d 的或运算结果为</p>
<pre><code>00000000 00000000 11011001 00100100
</code></pre>
<p>最终将 byte 数组又转成了 int.</p>
<h2 id="单个-byte-转成-int">单个 byte 转成 int</h2>
<p>根据上面的分析, 单个 byte 转成 int 其实就是将 byte 和 int 类型的 255 进行(&amp;)与运算即可.</p>
<pre><code>byte b = 25;
int a = b &amp; 0XFF; // 或者 b &amp; 255;
</code></pre>
<p>现在已经知道了在 Java 中通过补码来表示负数, 对于0和正数来说:原码,反码,补码都是一样的. 那么可以得出的结论是:对于 byte<code>[-128,127]</code>, 其<code>[0,127]</code>范围的数据和 int 中的 <code>[0,127]</code> 完全一致,不需要 <code>&amp; 0XFF</code>, 只有对于 <code>[-128,-1]</code> 的 byte 数据才需要 <code>&amp; 0XFF</code>.</p>
<pre><code>System.out.println(Integer.toHexString((byte)138 &amp; 0XFF).toUpperCase());
System.out.println(Integer.toHexString(138).toUpperCase());

System.out.println(Integer.toHexString((byte)-138 &amp; 0XFF).toUpperCase());
int a = (byte)-138 &amp; 0XFF;
System.out.println(&quot;a=&quot;+a);
System.out.println(Integer.toHexString(a).toUpperCase());
</code></pre>
<p>运行结果如下</p>
<pre><code>8A
8A
76
a=118
76
</code></pre>
<h2 id="最后一个问题">最后一个问题</h2>
<p><code>Integer.toHexString(b[n] &amp; 0XFF);</code>返回16进制的字符串，最长2个字符，最少1个字符，为什么？这个就相对简单了，无需研究 toHexString 方法的具体实现，实验的方法如下</p>
<pre><code>byte a = -128;
byte c = 0;
byte b = 127;
System.out.println(Integer.toHexString(a &amp; 0XFF));
System.out.println(Integer.toHexString(c &amp; 0XFF));
System.out.println(Integer.toHexString(b &amp; 0XFF));
</code></pre>
<p>返回的结果如下</p>
<pre><code>80
0
7f
</code></pre>
<p>对于 byte<code>[-128,127]</code> 转成16进制后都小于 <code>OXFF（255）</code>, 因此是不会超过3个字符串的。</p>

            </div>
            
            
              <div class="next-post">
                <div class="next">下一篇</div>
                <a href="https://blog.gankbat.com/post/markdown-yu-fa-shuo-ming">
                  <h3 class="post-title">
                    Markdown 语法说明
                  </h3>
                </a>
              </div>
            

            
              
                <div id="gitalk-container" data-aos="fade-in"></div>
              

              
            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>

<script type="application/javascript">

AOS.init();

hljs.initHighlightingOnLoad()

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>



  
    <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
    <script>

      var gitalk = new Gitalk({
        clientID: 'f751db22ae57516afa8d',
        clientSecret: 'fcc6deb1bef53b4d44ce6b61cd774fdd76da4b48',
        repo: 'gankbat.github.io',
        owner: 'gankbat',
        admin: ['gankbat'],
        id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
        distractionFreeMode: false  // Facebook-like distraction free mode
      })

      gitalk.render('gitalk-container')

    </script>
  

  




  </body>
</html>
